<!doctype html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1">

<link href="https://fonts.googleapis.com/css?family=Itim|Roboto+Mono:300,400,500,700&display=swap" rel="stylesheet">

<script src="js/lodash.min.js"></script>
<script src="js/d3.v5.min.js"></script>
<script src="js/vue.min.js"></script>

<style>

html, body, #app{
  height: 100%;
}

*{
  font-family: 'Roboto Mono', monospace;
  font-size:16px;

  background-color: black;
  color: white;
}


.fade-enter-active, .fade-leave-active {
  transition: opacity 1s;
}
.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ {
  opacity: 0;
}


.smaller, .smaller *{
  font-size: 16px;
}

div {
  margin-bottom: 12px;
}

.state-borders {
  fill: white;
  stroke: #fff;
  stroke-width: 0.5px;
  stroke-linejoin: round;
  stroke-linecap: round;
  pointer-events: none;
}

</style>

</head>

<body>


<div id="app">
<div style="position:relative; padding: 16px; margin-left:100px">

  <h1 style="font-size:60px">In an ideal world, how would you allocate the budget?</h1>

  <div>Tap to allocate budget</div>

  <div></div>

  <div v-for="(amount, dept) in budgetData">{{dept}}</div>

  <samples-chart></samples-chart>

</div> <!-- end center div -->
</div> <!-- end #app -->

<script type="text/x-template" id="samples-chart-template">
<div style="position:relative; display:inline-block" class="samples-chart">

<svg :width="chartWidth+margin.left+margin.right" 
     :height="chartHeight+margin.top+margin.bottom">
    <g v-if="isCreated && counts" 
      class="container"
      :transform="'translate(' + margin.left + ',' + margin.top + ')'">
<!--      <rect v-for="(count, x) in counts"
          :x="xScale(x)"
          :y="chartHeight - yScale(count)"
          :width="xScale.bandwidth()"
          :height="yScale(count)"
          :key="x"
          fill="#D1D9E0"/>  -->

        <g v-for="x in xdomain">
          <rect v-for="countInd in counts[x]"
          :x="xScale(x)"
          :y="chartHeight - yScale(counts[x]) + yScaleBandwidth*(countInd-1)+yPadBetweenBars"
          :width="xScale.bandwidth()"
          :height="yScaleBandwidth-yPadBetweenBars"
          :key="x + countInd"
          :fill="colors.bar || '#D1D9E0'"/>
        </g>


      <text v-for="x in xdomain" 
        :x="xScale(x)+ xScale.bandwidth()/2 - 4"
        :y="Math.max(0, chartHeight - yScale(counts[x]) - (isDraggable ? 8 : 2))">
        {{ counts[x] }}
      </text>

      <text v-if="showRatio"
        v-for="x in xdomain" 
        :x="xScale(x)+ xScale.bandwidth()/2 - 8"
        :y="chartHeight + 40"
        fill="#999">
        {{ prob(x) }}%
      </text>

    </g>
</svg>

  <div v-for="x in xdomain" 
      v-if="isDraggable && counts"
      class="dot"
      style="position:absolute"
      draggable="true"
      @dragstart="dragstart(x)"
      @dragend="dragend"
      @drag="drag(x, $event)"
      :style="dotStyle(x)"></div>


</div>
</script>


<script>

const wait = ms => new Promise(resolve => setTimeout(resolve, ms));


// 2020: in billions
const budgetData = {
'Agriculture': 20.8,
'Commerce': 12.2,
'Defense': 718,
'Education': 62,
'Energy': 31.7,
'Health & HS': 87.1,
'Homeland Security': 51.7,
'HUD': 44.1,
'Interior': 12.5,
'Justice': 29.2,
'Labor': 10.9,
'State & Intern': 40,
'Transportation*': 21.4,
'Treasury': 12.7,
'Veterans Affairs**': 93.1,
'Civil Works': 4.8,
'EPA': 6.1,
'NASA': 21,
};


Vue.component('samples-chart', {
  props: {
    xdomain: {type: Array}, // ['H', 'T']
    xLabels: {type: Array}, // ['P(H'), 'P(T)'] optional. Defaults to x-domain if not set.
    // Specify either samples or dist
    samples: {type: Array}, // ['H', 'H', 'H', 'T']
    dist: {type: Object}, // {H: 3, T: 1}
        
    chartHeight: {type: Number, default: 100},
    chartWidth: {type: Number, default: 100},
    margin: {
      type: Object, 
      default: function(){
        return {top: 10, right: 10, bottom: 40, left: 10};
      }
    },
    showRatio: {type: Boolean, default: false}, 
    isDraggable: {type: Boolean, default: false}, 
    // Minimum number of bars in y direction.
    minNumInY: {type: Number, default: 15},
    colors: {
      type: Object, 
      default: function(){
        return {bar: '', dot: ''};
      }
    },
  },
  computed: {
    xScale(){
      // Can only use for categorical domain.
      return d3.scaleBand()
          .domain(this.xdomain).paddingInner(.1).range([0, this.chartWidth]);
    },
    xText(){
      return this.xLabels || this.xdomain;
    },
    numBarsInY(){
      if (!this.samples){
        return this.minNumInY;
      }
      const bins = _.groupBy(this.samples);
      const maxBinLength = _.max(_.values(bins).map(arr => arr.length));
      return Math.max(this.minNumInY, maxBinLength);
    },
    yScale(){
      return d3.scaleLinear()
          .domain([0, this.numBarsInY]).range([0, this.chartHeight]);
    },
    yScaleBandwidth(){
      return this.chartHeight / this.numBarsInY;
    },
    yPadBetweenBars(){
      return this.numBarsInY < 40 ? 2 : 0;
    }
  },
  data: function(){
    return {
      isCreated: false,
      counts: null,
      draggedDot: null,
    }
  },
  created: function(){
    // Add domains
    this.isCreated = true;
  },
  mounted: async function() {
    this.countsFromProps();
    // Add the axis
    // Hack: for some reason axis needs to get added after a delay, or it doesn't show up.
    await wait(500);
    const this_ = this;
    var xAxis = d3.axisBottom(this.xScale).tickFormat(function(d, ind){
      return this_.xText[ind];
    }); //.ticks(8);
    const chart = d3.select(this.$el).select('.container');
    chart.append('g').attr('transform', 'translate(0,' + this.chartHeight + ')').call(xAxis);
  },
  watch: {
    samples(){
      this.countsFromProps();
    },
    dist(){
      this.countsFromProps();
    },
  },
  methods: {
    prob(x){
      const total = _.sum(_.values(this.counts));
      return this.$root.roundTo(this.counts[x]/total*100, 0);
    },
    dragstart(x){
      this.draggedDot = x;
    },
    dragend(){
      this.draggedDot = null; 
    },
    countsFromProps(){
      if (this.dist){
        this.counts = _.cloneDeep(this.dist);
      } else {
        const bins = _.groupBy(this.samples);
        this.counts = _.zipObject(this.xdomain, this.xdomain.map(function(x){
            return x in bins ? bins[x].length : 0;
          }));
      }
    },
    dotStyle(x){
      return {
        left: this.xScale(x)+ this.xScale.bandwidth()/2+ 4 + 'px', 
        bottom: this.yScale(this.counts[x]) + 24 + 'px',
        'background-color': this.colors.dot,
      };
    },
    drag(x, event){
      //console.log('dragging');
      //debugger;
      const distanceFromTop = this.getRelativeMouseY(event);
      if (distanceFromTop < 0){
        return;
      }
      const height = this.chartHeight - distanceFromTop;
      const numBars = Math.max(1, Math.floor(height / this.yScaleBandwidth));
      const isNewNumBars = this.counts[x] && this.counts[x] !== numBars;
      Vue.set(this.counts, x, numBars);
      if (isNewNumBars){
          this.$emit('dist-changed', {dist: this.counts});
      }
    },
    getRelativeMouseY: function(event){
      // Find the parent element to compute relative mouse coords.
      var refElement = event.target;
      while (refElement.className !== 'samples-chart'){
        refElement = refElement.parentElement;
      }
      return event.clientY - refElement.getBoundingClientRect().y;
    },
  },
  template: '#samples-chart-template'
});


// Gotchas:
// DOM does not update for new property additions.
// DOM does not update for direct assignments within arrays.
// https://vuejs.org/2016/02/06/common-gotchas/#Why-isn%E2%80%99t-the-DOM-updating  
new Vue({
  el: '#app',
  data: {
    budgetData: budgetData,
    selectedState: null,
    // selectedStates: [],
  },
});
</script>
